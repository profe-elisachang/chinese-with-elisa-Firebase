<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è­˜å­—èª²ç¨‹ Markdown ç®¡ç†å¾Œå°</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    
    <style>
        /* ==================== CSS Variables (è®¾è®¡ç³»ç»Ÿ) ==================== */
        :root {
            /* ä¸»è‰²è°ƒ */
            --primary-color: #0891b2;
            --primary-light: #06b6d4;
            --primary-dark: #0e7490;
            
            /* è¾…åŠ©è‰² */
            --secondary-color: #10b981;
            --accent-color: #f59e0b;
            --danger-color: #ef4444;
            
            /* ä¸­æ€§è‰² */
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            
            /* èƒŒæ™¯è‰² */
            --bg-page: #f9fafb;
            --bg-card: #ffffff;
            --bg-hover: #f3f4f6;
            --bg-light: #e5e7eb;
            
            /* è¾¹æ¡†è‰² */
            --border-light: #e5e7eb;
            --border-medium: #d1d5db;
            --border-dark: #9ca3af;
        }
        
        /* ==================== å…¨å±€æ ·å¼ ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-color) 50%, var(--primary-dark) 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* ==================== é¡¶éƒ¨å¯¼èˆªæ  ==================== */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: var(--primary-color);
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .header p {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        /* ==================== å¡ç‰‡æ ·å¼ ==================== */
        .card {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }
        
        .card h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        /* ==================== è¯¾ç¨‹é€‰æ‹©å™¨ ==================== */
        .lesson-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .lesson-selector label {
            font-weight: bold;
            color: var(--text-primary);
        }
        
        .lesson-selector select {
            padding: 10px 15px;
            border: 2px solid var(--border-medium);
            border-radius: 8px;
            font-size: 1em;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            min-width: 150px;
        }
        
        .lesson-selector select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* ==================== æŒ‰é’®æ ·å¼ ==================== */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(8, 145, 178, 0.3);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
        }
        
        .btn-accent {
            background: var(--accent-color);
            color: white;
        }
        
        .btn-accent:hover:not(:disabled) {
            background: #d97706;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        /* ==================== Markdown è¾“å…¥åŒºåŸŸ ==================== */
        .markdown-editor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid var(--border-medium);
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: #fafafa;
        }
        
        .markdown-editor:focus {
            outline: none;
            border-color: var(--primary-color);
            background: white;
        }
        
        /* ==================== å¤„ç†ç»“æœæ˜¾ç¤º ==================== */
        .status-panel {
            background: var(--bg-light);
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
        }
        
        .status-item.success {
            border-left: 4px solid var(--secondary-color);
        }
        
        .status-item.error {
            border-left: 4px solid var(--danger-color);
        }
        
        .status-item.info {
            border-left: 4px solid var(--primary-color);
        }
        
        .status-icon {
            font-size: 1.2em;
        }
        
        /* ==================== é¢„è§ˆé¢æ¿ ==================== */
        .preview-panel {
            display: none;
            margin-top: 20px;
        }
        
        .preview-panel.active {
            display: block;
        }
        
        .preview-section {
            margin-bottom: 25px;
            padding: 15px;
            background: var(--bg-light);
            border-radius: 8px;
        }
        
        .preview-section h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .preview-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .preview-table th {
            background: var(--primary-color);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        .preview-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .preview-table tr:last-child td {
            border-bottom: none;
        }
        
        .preview-table tr:hover {
            background: var(--bg-hover);
        }
        
        /* ==================== è¿›åº¦æ¡ ==================== */
        .progress-container {
            display: none;
            margin-top: 20px;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-light);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .progress-text {
            margin-top: 10px;
            text-align: center;
            color: var(--text-primary);
            font-weight: bold;
        }
        
        /* ==================== æ¶ˆæ¯æç¤º ==================== */
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s;
        }
        
        .message.success {
            background: var(--secondary-color);
            color: white;
        }
        
        .message.error {
            background: var(--danger-color);
            color: white;
        }
        
        .message.info {
            background: var(--primary-color);
            color: white;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* ==================== å“åº”å¼è®¾è®¡ ==================== */
        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .lesson-selector {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- é¡¶éƒ¨æ ‡é¢˜ -->
        <div class="header">
            <h1>ğŸ“š è­˜å­—èª²ç¨‹ Firestore å¾Œå°ç®¡ç†</h1>
            <p>å°‡ AI ç”Ÿæˆçš„ Markdown æ–‡æœ¬è§£æä¸¦ä¸Šå‚³åˆ° Firestore æ•¸æ“šåº«</p>
        </div>
        
        <!-- è¯¾ç¨‹é€‰æ‹© -->
        <div class="card">
            <div class="lesson-selector">
                <label for="lessonSelect">é¸æ“‡èª²ç¨‹ï¼š</label>
                <select id="lessonSelect">
                    <option value="">è«‹é¸æ“‡èª²ç¨‹</option>
                    <option value="1">è­˜å­— 1</option>
                    <option value="2">è­˜å­— 2</option>
                    <option value="3">è­˜å­— 3</option>
                    <option value="4">è­˜å­— 4</option>
                    <option value="5">è­˜å­— 5</option>
                    <option value="6">è­˜å­— 6</option>
                    <option value="7">è­˜å­— 7</option>
                    <option value="8">è­˜å­— 8</option>
                    <option value="9">è­˜å­— 9</option>
                    <option value="10">è­˜å­— 10</option>
                    <option value="11">è­˜å­— 11</option>
                    <option value="12">è­˜å­— 12</option>
                    <option value="13">è­˜å­— 13</option>
                    <option value="14">è­˜å­— 14</option>
                    <option value="15">è­˜å­— 15</option>
                    <option value="16">è­˜å­— 16</option>
                    <option value="17">è­˜å­— 17</option>
                    <option value="18">è­˜å­— 18</option>
                    <option value="19">è­˜å­— 19</option>
                    <option value="20">è­˜å­— 20</option>
                    <option value="21">è­˜å­— 21</option>
                    <option value="22">è­˜å­— 22</option>
                    <option value="23">è­˜å­— 23</option>
                    <option value="24">è­˜å­— 24</option>
                    <option value="25">è­˜å­— 25</option>
                </select>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="button-group">
                <button class="btn btn-primary" id="parseBtn">
                    ğŸ“¥ è§£æ Markdown
                </button>
                <button class="btn btn-secondary" id="previewBtn" disabled>
                    ğŸ‘ï¸ é è¦½æ•¸æ“š
                </button>
                <button class="btn btn-accent" id="uploadBtn" disabled>
                    ğŸ’¾ ä¸Šå‚³åˆ° Firestore
                </button>
                <button class="btn btn-secondary" id="exportBtn" disabled>
                    ğŸ“¤ å°å‡º Markdown
                </button>
            </div>
            
            <!-- Markdown è¾“å…¥åŒºåŸŸ -->
            <h2>Markdown è¼¸å…¥å€åŸŸ</h2>
            <textarea 
                id="markdownInput" 
                class="markdown-editor" 
                placeholder="è«‹åœ¨æ­¤è™•ç²˜è²¼ AI ç”Ÿæˆçš„ Markdown æ–‡æœ¬...

ç¯„ä¾‹æ ¼å¼ï¼š
## è¯†å­—11 - å­—è¡¨

| # | å­— | æ‹¼éŸ³ | è‹±æ–‡ | literacy_sentence |
|----|----|----|----|----|
| 1 | é€š | tÅng | open; notify; connect | ä¾‹å¥... |

## è¯†å­—11 - è¯ç»„

| è¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡ |
|----|----|---|
| é€šè¿‡ | tÅngguÃ² | by; pass through |

## è¯†å­—11 - è¯­æ³•

**è§„åˆ™1** (ä¸­æ–‡è¯´æ˜)
| è‹±æ–‡ç¿»è¯‘

## è¯†å­—11 - ç»ƒä¹ 

**å¡«ç©ºé¢˜**
1. é¢˜ç›®_A__B__C__D_ï¼Ÿ| ç­”æ¡ˆï¼šB | è¯ï¼šè¯è¯­

**é€‰æ‹©é¢˜**
1. é¢˜ç›®ï¼Ÿ| ç­”æ¡ˆï¼šD | A.é€‰|B.é€‰|C.é€‰|D.é€‰

**å¯¹è¯**
1. é—®ï¼šå¥å­ | ç­”ï¼šå¥å­"
            ></textarea>
        </div>
        
        <!-- å¤„ç†ç»“æœæ˜¾ç¤º -->
        <div class="card">
            <h2>è™•ç†çµæœ</h2>
            <div id="statusPanel" class="status-panel">
                <div class="status-item info">
                    <span class="status-icon">â„¹ï¸</span>
                    <span>ç­‰å¾…è§£æ Markdown æ–‡æœ¬...</span>
                </div>
            </div>
            
            <!-- è¿›åº¦æ¡ -->
            <div id="progressContainer" class="progress-container">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%">0%</div>
                </div>
                <div id="progressText" class="progress-text">æº–å‚™ä¸­...</div>
            </div>
        </div>
        
        <!-- é¢„è§ˆé¢æ¿ -->
        <div id="previewPanel" class="card preview-panel">
            <h2>æ•¸æ“šé è¦½</h2>
            <div id="previewContent"></div>
        </div>
    </div>
    
    <script>
        // ==================== Firebase é…ç½® ====================
        const firebaseConfig = {
            apiKey: "AIzaSyDMDTDwDP0mEXwgJdwsXVMB2IFi9Q5zfyU",
            authDomain: "shizi-with-elisa.firebaseapp.com",
            projectId: "shizi-with-elisa",
            storageBucket: "shizi-with-elisa.firebasestorage.app",
            messagingSenderId: "46368268308",
            appId: "1:46368268308:web:5847aeb7b239b16d624701"
        };
        
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        auth.signInAnonymously();
        
        // ==================== å…¨å±€å˜é‡ ====================
        let parsedData = {
            vocabulary: [],
            phrases: [],
            grammar: [],
            exercises: [],
            literacy_sentence: ''
        };
        
        let currentLessonId = null;
        
        // ==================== DOM å…ƒç´  ====================
        const lessonSelect = document.getElementById('lessonSelect');
        const markdownInput = document.getElementById('markdownInput');
        const parseBtn = document.getElementById('parseBtn');
        const previewBtn = document.getElementById('previewBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusPanel = document.getElementById('statusPanel');
        const previewPanel = document.getElementById('previewPanel');
        const previewContent = document.getElementById('previewContent');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        
        // ==================== äº‹ä»¶ç›‘å¬ ====================
        lessonSelect.addEventListener('change', (e) => {
            currentLessonId = e.target.value;
            if (currentLessonId) {
                loadLessonData(currentLessonId);
            }
        });
        
        parseBtn.addEventListener('click', handleParse);
        previewBtn.addEventListener('click', handlePreview);
        uploadBtn.addEventListener('click', handleUpload);
        exportBtn.addEventListener('click', handleExport);
        
        // ==================== Markdown è§£æå‡½æ•° ====================
        function parseMarkdown(markdown) {
            const result = {
                vocabulary: [],
                phrases: [],
                grammar: [],
                exercises: [],
                literacy_sentence: ''
            };
            
            // è§£æå­—è¡¨ï¼ˆæ”¯æŒå¤šç¨®æ¨™é¡Œæ ¼å¼ï¼‰
            const vocabMatch = markdown.match(/##\s*è¯†å­—\d+\s*-\s*å­—è¡¨\s*\n([\s\S]*?)(?=##|$)/i) || 
                              markdown.match(/##\s*å­—è¡¨\s*\n([\s\S]*?)(?=##|$)/i);
            if (vocabMatch) {
                result.vocabulary = parseVocabularyTable(vocabMatch[1]);
            }
            
            // è§£æè­˜å­—å¥ï¼ˆæ”¯æŒå¤šç¨®æ¨™é¡Œæ ¼å¼ï¼‰
            const literacyMatch = markdown.match(/##\s*è¯†å­—\d+\s*-\s*è¯†å­—å¥\s*\n([\s\S]*?)(?=##|$)/i) || 
                                 markdown.match(/##\s*è¯†å­—å¥\s*\n([\s\S]*?)(?=##|$)/i);
            if (literacyMatch) {
                result.literacy_sentence = parseLiteracySentence(literacyMatch[1]);
            }
            
            // è§£æè¯ç»„ï¼ˆæ”¯æŒå¤šç¨®æ¨™é¡Œæ ¼å¼ï¼‰
            const phrasesMatch = markdown.match(/##\s*è¯†å­—\d+\s*-\s*è¯ç»„\s*\n([\s\S]*?)(?=##|$)/i) || 
                                markdown.match(/##\s*è¯ç»„\s*\n([\s\S]*?)(?=##|$)/i);
            if (phrasesMatch) {
                result.phrases = parsePhrasesTable(phrasesMatch[1]);
            }
            
            // è§£æè¯­æ³•ï¼ˆæ”¯æŒå¤šç¨®æ¨™é¡Œæ ¼å¼ï¼‰
            const grammarMatch = markdown.match(/##\s*è¯†å­—\d+\s*-\s*è¯­æ³•\s*\n([\s\S]*?)(?=##|$)/i) || 
                                markdown.match(/##\s*è¯­æ³•\s*\n([\s\S]*?)(?=##|$)/i);
            if (grammarMatch) {
                result.grammar = parseGrammar(grammarMatch[1]);
            }
            
            // è§£æç»ƒä¹ ï¼ˆæ”¯æŒå¤šç¨®æ¨™é¡Œæ ¼å¼ï¼‰
            const exercisesMatch = markdown.match(/##\s*è¯†å­—\d+\s*-\s*ç»ƒä¹ \s*\n([\s\S]*?)(?=##|$)/i) || 
                                   markdown.match(/##\s*ç»ƒä¹ \s*\n([\s\S]*?)(?=##|$)/i);
            
            if (exercisesMatch && exercisesMatch[1]) {
                // æœ‰å®Œæ•´çš„ç·´ç¿’æ¨™é¡Œå’Œå…§å®¹
                result.exercises = parseExercises(exercisesMatch[1]);
            } else if (markdown.match(/(?:^|\n)###\s*(?:é€‰æ‹©é¢˜|å¡«ç©ºé¢˜|å¯¹è¯)/i)) {
                // å¦‚æœæ²’æœ‰å®Œæ•´çš„æ¨™é¡Œï¼Œä½†æª¢æ¸¬åˆ°ç·´ç¿’å­æ¨™é¡Œï¼ˆå¯èƒ½æ˜¯åªè²¼äº†ç·´ç¿’éƒ¨åˆ†ï¼‰
                // ç›´æ¥è§£ææ•´å€‹ markdown
                result.exercises = parseExercises(markdown);
            }
            
            return result;
        }
        
        // è§£æå­—è¡¨
        function parseVocabularyTable(text) {
            const vocab = [];
            const lines = text.split('\n').filter(line => line.trim());
            
            for (const line of lines) {
                if (!line.includes('|') || line.startsWith('|----')) continue;
                
                // ä¸è¦éæ¿¾ç©ºå­—ç¬¦ä¸²ï¼Œä¿ç•™æ‰€æœ‰æ¬„ä½ä»¥æ­£ç¢ºè™•ç†ç´¢å¼•
                const cells = line.split('|').map(c => c.trim());
                
                // è·³éè¡¨é ­è¡Œï¼ˆé€šå¸¸åŒ…å«"å­—"ã€"æ‹¼éŸ³"ç­‰é—œéµå­—ï¼‰
                if (cells.some(c => c === 'å­—' || c === 'æ‹¼éŸ³' || c === 'è‹±æ–‡' || c === 'notes' || c === '#' || c === 'literacy_sentence')) {
                    continue;
                }
                
                // è™•ç†è¡¨æ ¼æ ¼å¼ï¼š| å­— | æ‹¼éŸ³ | è‹±æ–‡ | notes |
                // cells[0] = "" (é–‹é ­çš„ |)
                // cells[1] = å­—
                // cells[2] = æ‹¼éŸ³
                // cells[3] = è‹±æ–‡
                // cells[4] = notes
                
                // æˆ–è€…æ²’æœ‰é–‹é ­ | çš„æ ¼å¼ï¼šå­— | æ‹¼éŸ³ | è‹±æ–‡ | notes
                // cells[0] = å­—
                // cells[1] = æ‹¼éŸ³
                // cells[2] = è‹±æ–‡
                // cells[3] = notes
                
                let character = '';
                let pinyin = '';
                let english = '';
                let notes = '';
                
                // åˆ¤æ–·æ˜¯å¦æœ‰é–‹é ­çš„ |
                if (cells[0] === '' && cells.length >= 5) {
                    // æ ¼å¼ï¼š| å­— | æ‹¼éŸ³ | è‹±æ–‡ | notes |
                    character = cells[1] || '';
                    pinyin = cells[2] || '';
                    english = cells[3] || '';
                    notes = cells[4] || '';
                } else if (cells.length >= 3) {
                    // æ ¼å¼ï¼šå­— | æ‹¼éŸ³ | è‹±æ–‡ | notesï¼ˆæ²’æœ‰é–‹é ­çš„ |ï¼‰
                    character = cells[0] || '';
                    pinyin = cells[1] || '';
                    english = cells[2] || '';
                    notes = cells[3] || '';
                }
                
                // è‡³å°‘è¦æœ‰å­—ã€æ‹¼éŸ³ã€è‹±æ–‡æ‰èƒ½æ·»åŠ 
                if (character && pinyin && english) {
                    vocab.push({
                        character: character,
                        meaning: `${pinyin}|${english}`, // pinyin|english
                        literacy_sentence: notes // notes æ¬„ä½å­˜åˆ° literacy_sentenceï¼ˆå‘å¾Œå…¼å®¹ï¼‰
                    });
                }
            }
            
            return vocab;
        }
        
        // è§£æè¯ç»„
        function parsePhrasesTable(text) {
            const phrases = [];
            const lines = text.split('\n').filter(line => line.trim());
            
            for (const line of lines) {
                if (!line.includes('|') || line.startsWith('|----')) continue;
                
                // ä¸è¦éæ¿¾ç©ºå­—ç¬¦ä¸²ï¼Œä¿ç•™æ‰€æœ‰æ¬„ä½ä»¥æ­£ç¢ºè™•ç†ç´¢å¼•
                const cells = line.split('|').map(c => c.trim());
                
                // è·³éè¡¨é ­è¡Œ
                if (cells.some(c => c === 'è¯ç»„' || c === 'æ‹¼éŸ³' || c === 'è‹±æ–‡')) {
                    continue;
                }
                
                // è™•ç†è¡¨æ ¼æ ¼å¼ï¼š| è¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡ |
                // cells[0] = "" (é–‹é ­çš„ |)
                // cells[1] = è¯ç»„
                // cells[2] = æ‹¼éŸ³
                // cells[3] = è‹±æ–‡
                
                // æˆ–è€…æ²’æœ‰é–‹é ­ | çš„æ ¼å¼ï¼šè¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡
                // cells[0] = è¯ç»„
                // cells[1] = æ‹¼éŸ³
                // cells[2] = è‹±æ–‡
                
                let content = '';
                let pinyin = '';
                let meaning = '';
                
                // åˆ¤æ–·æ˜¯å¦æœ‰é–‹é ­çš„ |
                if (cells[0] === '' && cells.length >= 4) {
                    // æ ¼å¼ï¼š| è¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡ |
                    content = cells[1] || '';
                    pinyin = cells[2] || '';
                    meaning = cells[3] || '';
                } else if (cells.length >= 3) {
                    // æ ¼å¼ï¼šè¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡ï¼ˆæ²’æœ‰é–‹é ­çš„ |ï¼‰
                    content = cells[0] || '';
                    pinyin = cells[1] || '';
                    meaning = cells[2] || '';
                }
                
                // è‡³å°‘è¦æœ‰è©çµ„ã€æ‹¼éŸ³ã€è‹±æ–‡æ‰èƒ½æ·»åŠ 
                if (content && pinyin && meaning) {
                    phrases.push({
                        content: content,
                        pinyin: pinyin,
                        meaning: meaning
                    });
                }
            }
            
            return phrases;
        }
        
        // è§£æè­˜å­—å¥
        function parseLiteracySentence(text) {
            // è­˜å­—å¥æ˜¯ç´”æ–‡æœ¬æ®µè½ï¼Œå»é™¤æ¨™é¡Œå’Œç©ºè¡Œ
            const lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => line && !line.startsWith('##') && !line.startsWith('#'))
                .join(' ')
                .trim();
            
            return lines;
        }
        
        // è§£æè¯­æ³•
        function parseGrammar(text) {
            const grammar = [];
            const lessonId = currentLessonId || '';
            
            // åŒ¹é… **è§„åˆ™X** (ä¸­æ–‡) | è‹±æ–‡ æ ¼å¼
            const ruleRegex = /\*\*è§„åˆ™(\d+)\*\*\s*\(([^)]+)\)\s*\|\s*(.+)/g;
            let match;
            
            while ((match = ruleRegex.exec(text)) !== null) {
                grammar.push({
                    lesson_id: lessonId,
                    subtype: 'rule',
                    chinese: match[2].trim(),
                    english: match[3].trim()
                });
            }
            
            // ä¹Ÿæ”¯æŒ **è§„åˆ™X** (ä¸­æ–‡)\n| è‹±æ–‡ æ ¼å¼ï¼ˆæ›è¡Œåˆ†éš”ï¼‰
            const lines = text.split('\n');
            let currentRule = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const ruleMatch = line.match(/\*\*è§„åˆ™(\d+)\*\*\s*\(([^)]+)\)/);
                if (ruleMatch) {
                    if (currentRule) {
                        grammar.push(currentRule);
                    }
                    currentRule = {
                        lesson_id: lessonId,
                        subtype: 'rule',
                        chinese: ruleMatch[2].trim(),
                        english: ''
                    };
                } else if (currentRule && line.startsWith('|')) {
                    currentRule.english = line.replace(/^\|\s*/, '').trim();
                    grammar.push(currentRule);
                    currentRule = null;
                }
            }
            if (currentRule) {
                grammar.push(currentRule);
            }
            
            return grammar;
        }
        
        // è§£æç»ƒä¹ 
        function parseExercises(text) {
            const exercises = [];
            let currentSubtype = null;
            
            // æŒ‰è¡Œè™•ç†ï¼Œä¿ç•™ç©ºè¡Œä»¥ä¾¿æª¢æ¸¬é¡Œç›®çµæŸ
            const lines = text.split('\n');
            let currentExercise = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // æ£€æµ‹å­ç±»å‹ï¼ˆæ”¯æŒå…©ç¨®æ ¼å¼ï¼š### å¡«ç©ºé¢˜ æˆ– **å¡«ç©ºé¢˜**ï¼‰
                if (line.match(/^###\s*å¡«ç©ºé¢˜/i) || line.match(/^\*\*å¡«ç©ºé¢˜\*\*/i)) {
                    // ä¿å­˜ä¸Šä¸€å€‹ç·´ç¿’
                    if (currentExercise) {
                        exercises.push(currentExercise);
                        currentExercise = null;
                    }
                    currentSubtype = 'fill_blank';
                    continue;
                } else if (line.match(/^###\s*é€‰æ‹©é¢˜/i) || line.match(/^\*\*é€‰æ‹©é¢˜\*\*/i)) {
                    // ä¿å­˜ä¸Šä¸€å€‹ç·´ç¿’
                    if (currentExercise) {
                        exercises.push(currentExercise);
                        currentExercise = null;
                    }
                    currentSubtype = 'multiple_choice';
                    continue;
                } else if (line.match(/^###\s*å¯¹è¯/i) || line.match(/^\*\*å¯¹è¯\*\*/i)) {
                    // ä¿å­˜ä¸Šä¸€å€‹ç·´ç¿’
                    if (currentExercise) {
                        exercises.push(currentExercise);
                        currentExercise = null;
                    }
                    currentSubtype = 'dialogue';
                    continue;
                }
                
                // è·³éç©ºè¡Œï¼ˆä½†ä¿ç•™ç•¶å‰ç·´ç¿’ç‹€æ…‹ï¼‰
                if (!line) {
                    continue;
                }
                
                // æª¢æ¸¬æ–°æ ¼å¼ï¼š**é¢˜ç›®1**: æˆ– **é¢˜ç›®1**:
                // æ”¯æŒä¸­æ–‡å†’è™Ÿå’Œè‹±æ–‡å†’è™Ÿ
                const newFormatMatch = line.match(/\*\*é¢˜ç›®\s*(\d+)\s*\*\*\s*[ï¼š:]\s*(.+)/);
                if (newFormatMatch) {
                    // å¦‚æœæœ‰æœªå®Œæˆçš„ç·´ç¿’ï¼Œå…ˆä¿å­˜
                    if (currentExercise) {
                        exercises.push(currentExercise);
                    }
                    // é–‹å§‹æ–°ç·´ç¿’
                    currentExercise = {
                        subtype: currentSubtype || 'fill_blank',
                        content: newFormatMatch[2].trim(),
                        answer: '',
                        options: ''
                    };
                    continue;
                }
                
                // æª¢æ¸¬èˆŠæ ¼å¼ï¼š1. é¡Œç›®|ç­”æ¡ˆ|é¸é …
                const oldFormatMatch = line.match(/^\d+\.\s*(.+)/);
                if (oldFormatMatch) {
                    // å¦‚æœæœ‰æœªå®Œæˆçš„ç·´ç¿’ï¼Œå…ˆä¿å­˜
                    if (currentExercise) {
                        exercises.push(currentExercise);
                    }
                    
                    const parts = line.split('|').map(p => p.trim());
                    let content = oldFormatMatch[1];
                    let answer = '';
                    let options = '';
                    
                    if (currentSubtype === 'fill_blank' || currentSubtype === 'multiple_choice') {
                        // å¾ç®¡é“ç¬¦åˆ†éš”çš„æ ¼å¼ä¸­æå–
                        if (parts.length >= 2) {
                            content = parts[0].replace(/^\d+\.\s*/, '');
                            answer = parts[1].replace(/ç­”æ¡ˆ[ï¼š:ä½ç½®]*\s*/, '') || '';
                        }
                        if (parts.length >= 3) {
                            if (currentSubtype === 'multiple_choice') {
                                // é€‰æ‹©é¢˜ï¼šé€‰é¡¹å¯èƒ½æ˜¯ A.é€‰|B.é€‰|C.é€‰|D.é€‰ æ ¼å¼
                                options = parts.slice(2).join('|');
                            } else {
                                // å¡«ç©ºé¢˜ï¼šå¯èƒ½æ˜¯ è¯ï¼šè¯è¯­ æˆ– å¡«ç©ºè¯ï¼šè¯è¯­ æ ¼å¼
                                options = parts[2].replace(/(è¯|å¡«ç©ºè¯)[ï¼š:]\s*/, '');
                            }
                        }
                    } else if (currentSubtype === 'dialogue') {
                        const question = parts[1] ? parts[1].replace(/é—®[ï¼š:]\s*/, '') : '';
                        const response = parts[2] ? parts[2].replace(/ç­”[ï¼š:]\s*/, '') : '';
                        content = `${question}|${response}`;
                    }
                    
                    currentExercise = {
                        subtype: currentSubtype || 'fill_blank',
                        content: content,
                        answer: answer,
                        options: options
                    };
                    continue;
                }
                
                // è™•ç†æ–°æ ¼å¼çš„ç­”æ¡ˆä¿¡æ¯ï¼ˆåˆ—è¡¨æ ¼å¼ï¼‰
                // åªæœ‰åœ¨æœ‰ç•¶å‰ç·´ç¿’æ™‚æ‰è™•ç†
                if (currentExercise) {
                    // ç­”æ¡ˆä½ç½®ï¼šC æˆ– ç­”æ¡ˆï¼šDï¼ˆæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡å†’è™Ÿï¼‰
                    const answerMatch = line.match(/^-\s*ç­”æ¡ˆ(ä½ç½®)?\s*[ï¼š:]\s*(.+)/);
                    if (answerMatch) {
                        currentExercise.answer = answerMatch[2].trim();
                        continue;
                    }
                    
                    // å¡«ç©ºè¯ï¼šè¢« æˆ– è¯ï¼šè¯è¯­ï¼ˆæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡å†’è™Ÿï¼‰
                    const wordMatch = line.match(/^-\s*(å¡«ç©º)?è¯\s*[ï¼š:]\s*(.+)/);
                    if (wordMatch) {
                        currentExercise.options = wordMatch[2].trim();
                        continue;
                    }
                    
                    // é€‰é¡¹ï¼šA.èƒ½|B.å¯ä»¥|C.æƒ³|D.ä¼šï¼ˆæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡å†’è™Ÿï¼‰
                    const optionsMatch = line.match(/^-\s*é€‰é¡¹\s*[ï¼š:]\s*(.+)/);
                    if (optionsMatch) {
                        currentExercise.options = optionsMatch[1].trim();
                        continue;
                    }
                }
            }
            
            // ä¿å­˜æœ€å¾Œä¸€å€‹ç·´ç¿’
            if (currentExercise) {
                exercises.push(currentExercise);
            }
            
            return exercises;
        }
        
        // ==================== å¤„ç†å‡½æ•° ====================
        function handleParse() {
            const markdown = markdownInput.value.trim();
            
            if (!markdown) {
                showMessage('è«‹è¼¸å…¥ Markdown æ–‡æœ¬', 'error');
                return;
            }
            
            if (!currentLessonId) {
                showMessage('è«‹å…ˆé¸æ“‡èª²ç¨‹', 'error');
                return;
            }
            
            try {
                parsedData = parseMarkdown(markdown);
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateStatusPanel(parsedData);
                
                // å¯ç”¨æŒ‰é’®
                previewBtn.disabled = false;
                uploadBtn.disabled = false;
                exportBtn.disabled = false;
                
                showMessage('âœ… Markdown è§£ææˆåŠŸï¼', 'success');
            } catch (error) {
                showMessage('âŒ è§£æå¤±æ•—ï¼š' + error.message, 'error');
                console.error(error);
            }
        }
        
        function handlePreview() {
            if (parsedData.vocabulary.length === 0 && 
                parsedData.phrases.length === 0 && 
                parsedData.grammar.length === 0 && 
                parsedData.exercises.length === 0 &&
                !parsedData.literacy_sentence) {
                showMessage('æ²’æœ‰æ•¸æ“šå¯é è¦½', 'error');
                return;
            }
            
            let html = '';
            
            // è­˜å­—å¥é è¦½
            if (parsedData.literacy_sentence && parsedData.literacy_sentence.trim()) {
                html += '<div class="preview-section">';
                html += '<h3>ğŸ“– è­˜å­—å¥</h3>';
                html += `<div style="padding: 15px; background: white; border-radius: 6px; line-height: 1.8; font-size: 1.1em;">${parsedData.literacy_sentence}</div>`;
                html += '</div>';
            }
            
            // å­—è¡¨é¢„è§ˆ
            if (parsedData.vocabulary.length > 0) {
                html += '<div class="preview-section">';
                html += '<h3>ğŸ“ å­—è¡¨ (' + parsedData.vocabulary.length + ' é …)</h3>';
                html += '<table class="preview-table">';
                html += '<tr><th>#</th><th>å­—</th><th>æ‹¼éŸ³</th><th>è‹±æ–‡</th><th>ä¾‹å¥</th></tr>';
                parsedData.vocabulary.forEach((item, idx) => {
                    const [pinyin, english] = item.meaning.split('|');
                    html += `<tr>
                        <td>${idx + 1}</td>
                        <td>${item.character}</td>
                        <td>${pinyin || ''}</td>
                        <td>${english || ''}</td>
                        <td>${item.literacy_sentence || ''}</td>
                    </tr>`;
                });
                html += '</table></div>';
            }
            
            // è¯ç»„é¢„è§ˆ
            if (parsedData.phrases.length > 0) {
                html += '<div class="preview-section">';
                html += '<h3>ğŸ“š è©çµ„ (' + parsedData.phrases.length + ' é …)</h3>';
                html += '<table class="preview-table">';
                html += '<tr><th>#</th><th>è©çµ„</th><th>æ‹¼éŸ³</th><th>è‹±æ–‡</th></tr>';
                parsedData.phrases.forEach((item, idx) => {
                    html += `<tr>
                        <td>${idx + 1}</td>
                        <td>${item.content}</td>
                        <td>${item.pinyin}</td>
                        <td>${item.meaning}</td>
                    </tr>`;
                });
                html += '</table></div>';
            }
            
            // è¯­æ³•é¢„è§ˆ
            if (parsedData.grammar.length > 0) {
                html += '<div class="preview-section">';
                html += '<h3>ğŸ“– èªæ³• (' + parsedData.grammar.length + ' é …)</h3>';
                html += '<table class="preview-table">';
                html += '<tr><th>#</th><th>ä¸­æ–‡</th><th>è‹±æ–‡</th></tr>';
                parsedData.grammar.forEach((item, idx) => {
                    html += `<tr>
                        <td>${idx + 1}</td>
                        <td>${item.chinese}</td>
                        <td>${item.english}</td>
                    </tr>`;
                });
                html += '</table></div>';
            }
            
            // ç»ƒä¹ é¢„è§ˆ
            if (parsedData.exercises.length > 0) {
                html += '<div class="preview-section">';
                html += '<h3>âœï¸ ç·´ç¿’ (' + parsedData.exercises.length + ' é …)</h3>';
                html += '<table class="preview-table">';
                html += '<tr><th>#</th><th>é¡å‹</th><th>é¡Œç›®</th><th>ç­”æ¡ˆ</th><th>é¸é …</th></tr>';
                parsedData.exercises.forEach((item, idx) => {
                    html += `<tr>
                        <td>${idx + 1}</td>
                        <td>${getExerciseTypeName(item.subtype)}</td>
                        <td>${item.content}</td>
                        <td>${item.answer}</td>
                        <td>${item.options || ''}</td>
                    </tr>`;
                });
                html += '</table></div>';
            }
            
            previewContent.innerHTML = html;
            previewPanel.classList.add('active');
        }
        
        function getExerciseTypeName(subtype) {
            const names = {
                'fill_blank': 'å¡«ç©º',
                'multiple_choice': 'é¸æ“‡',
                'dialogue': 'å°è©±'
            };
            return names[subtype] || subtype;
        }
        
        async function handleUpload() {
            if (!currentLessonId) {
                showMessage('è«‹å…ˆé¸æ“‡èª²ç¨‹', 'error');
                return;
            }
            
            // æª¢æŸ¥å“ªäº›éƒ¨åˆ†æœ‰æ•¸æ“š
            const hasVocabulary = parsedData.vocabulary.length > 0;
            const hasPhrases = parsedData.phrases.length > 0;
            const hasGrammar = parsedData.grammar.length > 0;
            const hasExercises = parsedData.exercises.length > 0;
            const hasLiteracySentence = parsedData.literacy_sentence && parsedData.literacy_sentence.trim().length > 0;
            
            if (!hasVocabulary && !hasPhrases && !hasGrammar && !hasExercises && !hasLiteracySentence) {
                showMessage('æ²’æœ‰æ•¸æ“šå¯ä¸Šå‚³', 'error');
                return;
            }
            
            // æ§‹å»ºæ›´æ–°åˆ—è¡¨
            const updateList = [];
            if (hasVocabulary) updateList.push(`å­—è¡¨ (${parsedData.vocabulary.length} é …)`);
            if (hasLiteracySentence) updateList.push(`è­˜å­—å¥`);
            if (hasPhrases) updateList.push(`è©çµ„ (${parsedData.phrases.length} é …)`);
            if (hasGrammar) updateList.push(`èªæ³• (${parsedData.grammar.length} é …)`);
            if (hasExercises) updateList.push(`ç·´ç¿’ (${parsedData.exercises.length} é …)`);
            
            // ç¢ºèªå°è©±æ¡†
            const confirmMsg = `ç¢ºå®šè¦æ›´æ–°è­˜å­— ${currentLessonId} çš„ä»¥ä¸‹æ•¸æ“šï¼Ÿ\n\nå°‡æ›´æ–°ï¼š\n${updateList.join('\n')}\n\nâš ï¸ æ³¨æ„ï¼šå…¶ä»–æœªæ›´æ–°çš„æ•¸æ“šå°‡ä¿æŒä¸è®Š`;
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            uploadBtn.disabled = true;
            progressContainer.classList.add('active');
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            progressText.textContent = 'æ­£åœ¨è®€å–ç¾æœ‰æ•¸æ“š...';
            
            try {
                const lessonDocId = `lesson${currentLessonId}`;
                
                // å…ˆè®€å–ç¾æœ‰æ•¸æ“š
                const docRef = db.collection('lessons').doc(lessonDocId);
                const doc = await docRef.get();
                
                // ç²å–ç¾æœ‰æ•¸æ“šï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                let existingData = {};
                if (doc.exists) {
                    existingData = doc.data();
                }
                
                progressText.textContent = 'æ­£åœ¨åˆä½µæ•¸æ“š...';
                progressFill.style.width = '50%';
                progressFill.textContent = '50%';
                
                // æ§‹å»ºæ›´æ–°æ•¸æ“šï¼ˆåªåŒ…å«æœ‰å…§å®¹çš„éƒ¨åˆ†ï¼‰
                const dataToUpload = {};
                
                // ç²å–æœ€çµ‚çš„æ•¸æ“šï¼ˆæ–°æ•¸æ“šå„ªå…ˆï¼Œå¦å‰‡ä¿ç•™ç¾æœ‰æ•¸æ“šï¼‰
                const finalVocabulary = hasVocabulary ? parsedData.vocabulary : (existingData.vocabulary || []);
                const finalPhrases = hasPhrases ? parsedData.phrases : (existingData.phrases || []);
                const finalGrammar = hasGrammar ? parsedData.grammar : (existingData.grammar || []);
                const finalExercises = hasExercises ? parsedData.exercises : (existingData.exercises || []);
                
                // åªæ›´æ–°æœ‰æ•¸æ“šçš„éƒ¨åˆ†ï¼ˆä½¿ç”¨ merge: true æ™‚ï¼Œä¸åŒ…å«çš„å­—æ®µæœƒä¿ç•™ï¼‰
                // æ³¨æ„ï¼švocabulary, phrases, grammar, exercises æ‡‰è©²åœ¨æ ¹ç´šåˆ¥ï¼Œä¸æ˜¯ components å°è±¡å…§
                // åŒæ™‚éœ€è¦è½‰æ›æ•¸æ“šæ ¼å¼ä»¥åŒ¹é… lesson.html çš„æœŸæœ›æ ¼å¼
                
                if (hasVocabulary) {
                    // è½‰æ› vocabulary æ ¼å¼ï¼šå¾ {character, meaning: "pinyin|english", literacy_sentence}
                    // è½‰æ›ç‚º {content: "å­—|pinyin|english", notes: "literacy_sentence"}
                    dataToUpload.vocabulary = parsedData.vocabulary.map(item => {
                        // è§£æ meaning å­—æ®µï¼ˆæ ¼å¼ï¼špinyin|englishï¼‰
                        const meaningParts = (item.meaning || '').split('|').map(s => s.trim());
                        const pinyin = meaningParts[0] || '';
                        const english = meaningParts[1] || '';
                        
                        // æ§‹å»º content å­—æ®µï¼ˆæ ¼å¼ï¼šå­—|pinyin|englishï¼‰
                        const content = `${item.character || ''}|${pinyin}|${english}`;
                        
                        return {
                            content: content,
                            notes: item.literacy_sentence || ''
                        };
                    });
                }
                
                if (hasPhrases) {
                    // è½‰æ› phrases æ ¼å¼ï¼šå¾ {content: "è©çµ„", pinyin: "pinyin", meaning: "english"}
                    // è½‰æ›ç‚º {content: "è©çµ„|pinyin|english", subtype: "phrase"}
                    dataToUpload.phrases = parsedData.phrases.map(item => {
                        const content = `${item.content || ''}|${item.pinyin || ''}|${item.meaning || ''}`;
                        return {
                            content: content,
                            subtype: 'phrase'  // æ·»åŠ  subtype å­—æ®µï¼Œè®“ renderPhrases èƒ½æ­£ç¢ºéæ¿¾
                        };
                    });
                }
                
                if (hasGrammar) {
                    // è½‰æ› grammar æ ¼å¼ï¼šå¾ {chinese: "ä¸­æ–‡", english: "è‹±æ–‡"}
                    // è½‰æ›ç‚º {content: "ä¸­æ–‡|è‹±æ–‡", subtype: "rule"}
                    dataToUpload.grammar = parsedData.grammar.map(item => {
                        const content = `${item.chinese || ''}|${item.english || ''}`;
                        return {
                            content: content,
                            subtype: item.subtype || 'rule'
                        };
                    });
                }
                
                if (hasExercises) {
                    // exercises æ ¼å¼å·²ç¶“æ­£ç¢ºï¼Œç›´æ¥ä½¿ç”¨
                    dataToUpload.exercises = parsedData.exercises;
                }
                
                // ä¸Šå‚³è­˜å­—å¥ï¼ˆæ ¹ç´šåˆ¥å­—æ®µï¼‰
                if (hasLiteracySentence) {
                    dataToUpload.literacy_sentence = parsedData.literacy_sentence.trim();
                }
                
                // ç¢ºä¿ components æ˜¯æ•¸çµ„é¡å‹ï¼ˆå­—ç¬¦éƒ¨ä»¶ï¼Œä¸æ˜¯å°è±¡å®¹å™¨ï¼‰
                // å¦‚æœç¾æœ‰æ•¸æ“šæœ‰ components æ•¸çµ„ï¼Œä¿ç•™å®ƒï¼›å¦‚æœæ²’æœ‰æˆ–æ ¼å¼éŒ¯èª¤ï¼Œè¨­ç‚ºç©ºæ•¸çµ„
                if (existingData.components && Array.isArray(existingData.components)) {
                    // ä¿ç•™ç¾æœ‰çš„å­—ç¬¦éƒ¨ä»¶æ•¸çµ„
                    dataToUpload.components = existingData.components;
                } else {
                    // å¦‚æœä¸å­˜åœ¨æˆ–æ˜¯éŒ¯èª¤çš„å°è±¡æ ¼å¼ï¼Œè¨­ç‚ºç©ºæ•¸çµ„ï¼ˆé¿å… components.map éŒ¯èª¤ï¼‰
                    // é€™æ¨£å¯ä»¥æ¸…ç†ä¹‹å‰éŒ¯èª¤ä¸Šå‚³çš„ components å°è±¡
                    dataToUpload.components = [];
                }
                
                // æ›´æ–° meta æ•¸æ“šï¼ˆç¸½æ˜¯æ›´æ–°ï¼Œå› ç‚ºè¨ˆæ•¸å¯èƒ½æ”¹è®Šï¼‰
                dataToUpload.meta = {
                    component_count: finalVocabulary.length + finalPhrases.length + finalGrammar.length,
                    exercises_count: finalExercises.length,
                    vocabulary_count: finalVocabulary.length,
                    phrases_count: finalPhrases.length,
                    grammar_count: finalGrammar.length,
                    last_updated: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                progressText.textContent = 'æ­£åœ¨ä¸Šå‚³åˆ° Firestore...';
                progressFill.style.width = '75%';
                progressFill.textContent = '75%';
                
                // ä¸Šå‚³åˆ° Firestoreï¼ˆä½¿ç”¨ merge: true ç¢ºä¿åªæ›´æ–°æŒ‡å®šå­—æ®µï¼‰
                await docRef.set(dataToUpload, { merge: true });
                
                progressFill.style.width = '100%';
                progressFill.textContent = '100%';
                progressText.textContent = 'âœ… ä¸Šå‚³æˆåŠŸï¼';
                
                // æ§‹å»ºæˆåŠŸæ¶ˆæ¯
                const successMsg = `ğŸ‰ æˆåŠŸæ›´æ–°è­˜å­— ${currentLessonId}ï¼\n\nå·²æ›´æ–°ï¼š${updateList.join('ã€')}`;
                showMessage(successMsg, 'success');
                
                // æ›´æ–°ç‹€æ…‹é¢æ¿
                updateStatusPanel(parsedData, true);
                
                setTimeout(() => {
                    progressContainer.classList.remove('active');
                    uploadBtn.disabled = false;
                }, 2000);
                
            } catch (error) {
                showMessage('âŒ ä¸Šå‚³å¤±æ•—ï¼š' + error.message, 'error');
                console.error(error);
                uploadBtn.disabled = false;
                progressContainer.classList.remove('active');
            }
        }
        
        function handleExport() {
            if (parsedData.vocabulary.length === 0 && 
                parsedData.phrases.length === 0 && 
                parsedData.grammar.length === 0 && 
                parsedData.exercises.length === 0) {
                showMessage('æ²’æœ‰æ•¸æ“šå¯å°å‡º', 'error');
                return;
            }
            
            let markdown = `## è¯†å­—${currentLessonId || 'X'} - å­—è¡¨\n\n`;
            markdown += '| # | å­— | æ‹¼éŸ³ | è‹±æ–‡ | literacy_sentence |\n';
            markdown += '|----|----|----|----|----|\n';
            
            parsedData.vocabulary.forEach((item, idx) => {
                const [pinyin, english] = item.meaning.split('|');
                markdown += `| ${idx + 1} | ${item.character} | ${pinyin || ''} | ${english || ''} | ${item.literacy_sentence || ''} |\n`;
            });
            
            // è­˜å­—å¥
            if (parsedData.literacy_sentence && parsedData.literacy_sentence.trim()) {
                markdown += `\n## è¯†å­—${currentLessonId || 'X'} - è¯†å­—å¥\n\n`;
                markdown += parsedData.literacy_sentence + '\n';
            }
            
            markdown += `\n## è¯†å­—${currentLessonId || 'X'} - è¯ç»„\n\n`;
            markdown += '| è¯ç»„ | æ‹¼éŸ³ | è‹±æ–‡ |\n';
            markdown += '|----|----|---|\n';
            
            parsedData.phrases.forEach(item => {
                markdown += `| ${item.content} | ${item.pinyin} | ${item.meaning} |\n`;
            });
            
            markdown += `\n## è¯†å­—${currentLessonId || 'X'} - è¯­æ³•\n\n`;
            parsedData.grammar.forEach((item, idx) => {
                markdown += `**è§„åˆ™${idx + 1}** (${item.chinese})\n`;
                markdown += `| ${item.english}\n\n`;
            });
            
            markdown += `\n## è¯†å­—${currentLessonId || 'X'} - ç»ƒä¹ \n\n`;
            
            // æŒ‰ç±»å‹åˆ†ç»„ç»ƒä¹ 
            const fillBlank = parsedData.exercises.filter(e => e.subtype === 'fill_blank');
            const multipleChoice = parsedData.exercises.filter(e => e.subtype === 'multiple_choice');
            const dialogue = parsedData.exercises.filter(e => e.subtype === 'dialogue');
            
            if (fillBlank.length > 0) {
                markdown += '**å¡«ç©ºé¢˜**\n';
                fillBlank.forEach((item, idx) => {
                    markdown += `${idx + 1}. ${item.content}| ç­”æ¡ˆï¼š${item.answer} | è¯ï¼š${item.options}\n`;
                });
                markdown += '\n';
            }
            
            if (multipleChoice.length > 0) {
                markdown += '**é€‰æ‹©é¢˜**\n';
                multipleChoice.forEach((item, idx) => {
                    markdown += `${idx + 1}. ${item.content}| ç­”æ¡ˆï¼š${item.answer} | ${item.options}\n`;
                });
                markdown += '\n';
            }
            
            if (dialogue.length > 0) {
                markdown += '**å¯¹è¯**\n';
                dialogue.forEach((item, idx) => {
                    const [question, response] = item.content.split('|');
                    markdown += `${idx + 1}. é—®ï¼š${question || ''} | ç­”ï¼š${response || ''}\n`;
                });
            }
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `è¯†å­—${currentLessonId || 'X'}_export.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('âœ… Markdown å°å‡ºæˆåŠŸï¼', 'success');
        }
        
        // ==================== è¾…åŠ©å‡½æ•° ====================
        function updateStatusPanel(data, uploaded = false) {
            let html = '';
            
            if (uploaded) {
                html += '<div class="status-item success">';
                html += '<span class="status-icon">âœ…</span>';
                html += '<span>æ•¸æ“šå·²æˆåŠŸä¸Šå‚³åˆ° Firestore</span>';
                html += '</div>';
            }
            
            html += '<div class="status-item success">';
            html += `<span class="status-icon">âœ…</span>`;
            html += `<span>å­—è¡¨è§£ææˆåŠŸ (${data.vocabulary.length} é …)</span>`;
            html += '</div>';
            
            if (data.literacy_sentence && data.literacy_sentence.trim()) {
                html += '<div class="status-item success">';
                html += `<span class="status-icon">âœ…</span>`;
                html += `<span>è­˜å­—å¥è§£ææˆåŠŸ</span>`;
                html += '</div>';
            }
            
            html += '<div class="status-item success">';
            html += `<span class="status-icon">âœ…</span>`;
            html += `<span>è©çµ„è§£ææˆåŠŸ (${data.phrases.length} é …)</span>`;
            html += '</div>';
            
            html += '<div class="status-item success">';
            html += `<span class="status-icon">âœ…</span>`;
            html += `<span>èªæ³•è§£ææˆåŠŸ (${data.grammar.length} é …)</span>`;
            html += '</div>';
            
            html += '<div class="status-item success">';
            html += `<span class="status-icon">âœ…</span>`;
            html += `<span>ç·´ç¿’è§£ææˆåŠŸ (${data.exercises.length} é …)</span>`;
            html += '</div>';
            
            statusPanel.innerHTML = html;
        }
        
        function showMessage(text, type = 'info') {
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => message.remove(), 300);
            }, 3000);
        }
        
        // ==================== åŠ è½½è¯¾ç¨‹æ•°æ® ====================
        async function loadLessonData(lessonId) {
            try {
                const lessonDocId = `lesson${lessonId}`;
                const doc = await db.collection('lessons').doc(lessonDocId).get();
                
                if (doc.exists) {
                    const data = doc.data();
                    if (data.components) {
                        // å¦‚æœæœ‰ç°æœ‰æ•°æ®ï¼Œå¯ä»¥æ˜¾ç¤ºæç¤º
                        showMessage(`å·²æ‰¾åˆ°è­˜å­— ${lessonId} çš„ç¾æœ‰æ•¸æ“š`, 'info');
                    }
                }
            } catch (error) {
                console.error('è¼‰å…¥èª²ç¨‹æ•¸æ“šå¤±æ•—ï¼š', error);
            }
        }
    </script>
</body>
</html>

